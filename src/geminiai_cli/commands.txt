#!/usr/bin/env python3

import os
import re
import time
from typing import Tuple
import subprocess        # <<<< ADDED
import shutil           # <<<< ADDED

from .ui import banner, cprint
from .utils import run, run_capture, read_file
from .config import *

# Reusable safe command runner with automatic Gemini reset-time capture
def run_cmd_safe(cmd: str, timeout: int = 30, capture: bool = True) -> Tuple[int, str, str]:
    """
    Run shell command with timeout. Returns (rc, stdout, stderr).
    Automatically detects Gemini rate-limit messages and saves reset time.
    stdout/stderr are always strings ('' if not captured).
    """
    try:
        proc = subprocess.run(cmd, shell=True, capture_output=capture, text=True, timeout=timeout)
        out = proc.stdout or ""
        err = proc.stderr or ""

        # --- AUTO SAVE GEMINI RESET TIME ---
        combined_output = out + err
        save_reset_time_from_output(combined_output)

        return proc.returncode, out, err

    except subprocess.TimeoutExpired as e:
        out = getattr(e, "output", "") or ""
        err = getattr(e, "stderr", "") or f"Timeout after {timeout}s"

        if isinstance(out, bytes):
            out = out.decode(errors="ignore")
        if isinstance(err, bytes):
            err = err.decode(errors="ignore")

        # --- AUTO SAVE GEMINI RESET TIME ---
        save_reset_time_from_output(out + err)

        return 124, out, err

    except Exception as e:
        # --- AUTO SAVE GEMINI RESET TIME ---
        save_reset_time_from_output(str(e))

        return 1, "", str(e)
            
                    
# Improved do_login
def do_login(retries: int = 2, wait_between: float = 0.8):
    """
    Robust login flow:
     - Runs gemini, attempts to extract an auth URL or verification code via regex.
     - If first-run menu appears, auto-select Browser Login by sending an ENTER.
     - Writes to LOGIN_URL_PATH (from config) and shows a safe preview to user.
    """
    banner()
    cprint(NEON_YELLOW, "[INFO] Starting Gemini login flow...")
    cprint(NEON_YELLOW, f"[INFO] Saving output to: {NEON_CYAN}{LOGIN_URL_PATH}{RESET}")

    # Helper to parse URLs and possible verification codes
    url_regex = re.compile(r"https?://[^\s'\"<>]+")
    code_regex = re.compile(r"(?i)verification code[:\s]*([A-Za-z0-9\-_=]{4,})")

    # First attempt: run gemini capturing stderr (where gemini prints)
    for attempt in range(1, retries + 1):
        cprint(NEON_YELLOW, f"[INFO] Running gemini (attempt {attempt}/{retries})...")
        rc, out, err = run_cmd_safe(f"gemini 2> {LOGIN_URL_PATH}", timeout=30, capture=True)
        # read file if exists
        try:
            raw = read_file(LOGIN_URL_PATH)
        except Exception:
            raw = (err or "") + (out or "")
        text = (raw or "").strip()

        # quick search for obvious signs
        found_urls = url_regex.findall(text)
        found_codes = code_regex.findall(text)

        if found_urls or found_codes:
            # Success — at least we have something to show
            cprint(NEON_GREEN, "[OK] Authentication output captured.")
            break

        # If output does not contain URL/code, check for first-run menu hint and try the ENTER trick
        lower = text.lower()
        if ("choose a login method" in lower) or ("browser login" in lower) or ("press enter" in lower) or ("choose an option" in lower):
            cprint(NEON_MAGENTA, "[INFO] FIRST RUN / interactive menu detected — selecting Browser Login (send ENTER).")
            rc2, out2, err2 = run_cmd_safe(f'printf "\\n" | gemini 2> {LOGIN_URL_PATH}', timeout=15, capture=True)
            # after selecting, run gemini again to capture the URL
            time.sleep(wait_between)
            rc3, out3, err3 = run_cmd_safe(f"gemini 2> {LOGIN_URL_PATH}", timeout=30, capture=True)
            try:
                text = read_file(LOGIN_URL_PATH)
            except Exception:
                text = (err3 or "") + (out3 or "")
            found_urls = url_regex.findall(text)
            found_codes = code_regex.findall(text)
            if found_urls or found_codes:
                break

        # If nothing found and not last attempt, wait & retry
        if attempt < retries:
            time.sleep(wait_between)
        else:
            cprint(NEON_RED, "[ERROR] Could not extract login URL or verification code from gemini output.")
            cprint(NEON_YELLOW, f"[INFO] Show file preview (first 15 lines) from {LOGIN_URL_PATH} if present.")
            try:
                raw = read_file(LOGIN_URL_PATH)
            except Exception:
                raw = None
            preview = ("\n".join((raw or "").splitlines()[:15])) if raw else "(no file)"
            cprint(NEON_MAGENTA, "Preview:")
            print(preview + "\n")
            return

    # At this point `text` contains the latest file contents
    # Extract and print a safe preview and show instructions
    preview = "\n".join(text.splitlines()[:15])
    cprint(NEON_MAGENTA, "Preview:")
    print(preview + "\n")

    # If we have a URL, show it clearly
    if found_urls:
        cprint(NEON_GREEN, "[OK] Found URL(s):")
        for u in found_urls:
            cprint(NEON_CYAN, f"  {u}")
    if found_codes:
        cprint(NEON_GREEN, "[OK] Found verification code(s):")
        for code in found_codes:
            cprint(NEON_CYAN, f"  {code}")

    cprint(NEON_YELLOW, "✔ Open the URL in your browser")
    cprint(NEON_YELLOW, "✔ Complete the login")
    cprint(NEON_YELLOW, "✔ Copy the verification code shown in the browser")
    cprint(NEON_YELLOW, "✔ Paste the code into the Gemini CLI when prompted\n")

    cprint(NEON_CYAN, "[INFO] Full file (not printed here for safety):")
    cprint(NEON_MAGENTA, f"  cat {LOGIN_URL_PATH}\n")


# Improved do_update (standardized on run_cmd_safe)
def do_update():
    banner()
    cprint(NEON_YELLOW, "[INFO] Updating Gemini CLI...")

    # Remove old symlink (ignore errors)
    run_cmd_safe("rm -f /usr/bin/gemini", timeout=5)

    # Query npm global root
    rc, npm_root, npm_err = run_cmd_safe("npm root -g", timeout=8, capture=True)
    npm_root = (npm_root or "").strip()
    if rc != 0 or not npm_root:
        cprint(NEON_YELLOW, f"[WARN] Could not determine npm global root (rc={rc}). Falling back to /usr/lib/node_modules")
        npm_root = "/usr/lib/node_modules"

    google_pkg_dir = os.path.join(npm_root, "@google")
    if os.path.exists(google_pkg_dir):
        cprint(NEON_YELLOW, f"[INFO] Removing existing {google_pkg_dir} ...")
        try:
            shutil.rmtree(google_pkg_dir)
            cprint(NEON_GREEN, f"[OK] Removed {google_pkg_dir}")
        except Exception as e:
            cprint(NEON_RED, f"[ERROR] Failed to remove {google_pkg_dir}: {e}")
    else:
        cprint(NEON_GREEN, f"[OK] {google_pkg_dir} does not exist — nothing to remove.")

    # Show npm root contents for debugging — non-fatal
    if os.path.exists(npm_root):
        rc_ls, ls_out, ls_err = run_cmd_safe(f"ls -la {npm_root}", timeout=6, capture=True)
        if rc_ls == 0:
            cprint(NEON_GREEN, f"[INFO] npm root contents:\n{ls_out}")
        else:
            cprint(NEON_YELLOW, f"[WARN] ls returned rc={rc_ls}\n{ls_err or ''}")

    # Install / update gemini CLI
    cprint(NEON_YELLOW, "[INFO] Running npm install -g @google/gemini-cli ...")
    rc_install, out_install, err_install = run_cmd_safe("npm install -g @google/gemini-cli", timeout=300, capture=True)
    
    if rc_install == 0:
        cprint(NEON_GREEN, "\n[OK] Update complete. Installed version (npm output snippet):")
        snippet = "\n".join((out_install or "").splitlines()[-6:])
        cprint(NEON_GREEN, snippet)

    else:
        cprint(NEON_RED, f"\n[ERROR] npm install failed (rc={rc_install}).")
        cprint(NEON_RED, (err_install or out_install or "No output."))
        cprint(NEON_YELLOW, "[INFO] Trying with --unsafe-perm ...")
        rc2, out2, err2 = run_cmd_safe("npm install -g --unsafe-perm @google/gemini-cli", timeout=300, capture=True)
        if rc2 == 0:
            cprint(NEON_GREEN, "[OK] Update succeeded with --unsafe-perm.")
        else:
            cprint(NEON_RED, "[ERROR] Update failed even with --unsafe-perm.")
            cprint(NEON_RED, (err2 or out2 or "No additional output."))
            # diagnostic: show npm bin and suggest symlink
            rc_bin, npm_bin, _ = run_cmd_safe("npm bin -g", timeout=6, capture=True)
            npm_bin = (npm_bin or "").strip()
            if npm_bin:
                cprint(NEON_YELLOW, f"[INFO] npm global bin: {npm_bin}")
                cprint(NEON_YELLOW, f"[TIP] If gemini is installed here, you can symlink: ln -sf {npm_bin}/gemini /usr/bin/gemini")
    # done


def do_check_update():
    banner()
    cprint(NEON_YELLOW, "[INFO] Checking Gemini CLI version...")

    # Quick check: is gemini on PATH?
    rc_path, gem_path, _ = run_cmd_safe("command -v gemini", timeout=3, capture=True)
    gem_path = (gem_path or "").strip()
    if rc_path != 0 or not gem_path:
        cprint(NEON_RED, "[ERROR] 'gemini' not found on PATH. Is it installed?")
        cprint(NEON_YELLOW, "Try: npm install -g @google/gemini-cli  or check your PATH.")
        return

    cprint(NEON_CYAN, f"[INFO] Found gemini at: {NEON_GREEN}{gem_path}")

    # Run version with stdin redirected from /dev/null to avoid interactive hangs,
    # and give it a generous timeout for slow environments.
    rc_inst, installed, err_inst = run_cmd_safe("gemini --version < /dev/null", timeout=30, capture=True)
    installed = (installed or "").strip()
    if rc_inst != 0 or not installed:
        cprint(NEON_RED, "[ERROR] Gemini is installed but `gemini --version` failed or timed out.")
        cprint(NEON_YELLOW, f"[DEBUG] gemini --version rc={rc_inst} stderr: {err_inst}")
        cprint(NEON_YELLOW, "You can try running `gemini --version` manually to see interactive prompts.")
        return

    # Get latest package version from npm
    rc_latest, latest, err_latest = run_cmd_safe("npm view @google/gemini-cli version", timeout=10, capture=True)
    latest = (latest or "").strip()
    if rc_latest != 0 or not latest:
        cprint(NEON_YELLOW, "[WARN] Could not determine latest version via npm view.")
        cprint(NEON_YELLOW, f"[DEBUG] stderr: {err_latest}")
        cprint(NEON_CYAN, "Try: npm view @google/gemini-cli version --json")
        latest = "(unknown)"

    cprint(NEON_CYAN, f"Installed version: {NEON_GREEN}{installed}")
    cprint(NEON_CYAN, f"Latest version:    {NEON_GREEN}{latest}")

    if latest != "(unknown)" and installed == latest:
        cprint(NEON_GREEN, "\n[OK] You already have the latest version!")
        return

    cprint(NEON_MAGENTA, "\n⚡ Update available!")
    choice = input(NEON_YELLOW + "Do you want to update? (y/n): " + RESET).strip().lower()
    if choice == "y":
        do_update()
    else:
        cprint(NEON_CYAN, "Update cancelled.\n")
        

def do_logout():
    banner()

    gemini_dir = os.path.expanduser("~/.gemini")

    cprint(NEON_YELLOW, "[INFO] Logging out from Gemini CLI...")
    cprint(NEON_YELLOW, f"[INFO] Removing: {NEON_CYAN}{gemini_dir}{RESET}")

    if os.path.exists(gemini_dir):
        run(f"rm -rf {gemini_dir}")
        cprint(NEON_GREEN, "[OK] Directory removed.")
    else:
        cprint(NEON_GREEN, "[OK] Already logged out (directory missing).")

    cprint(NEON_YELLOW, "\n[INFO] Confirming logout status:")
    run("ls -d ~/.gemini || echo '[OK] Logout complete.'")


from datetime import datetime, timedelta, timezone
import re, os

RESET_TIME_FILE = os.path.expanduser("~/.gemini_last_reset_time")

def save_reset_time_from_output(text: str):
    pattern = r"Access resets at (\d{1,2}:\d{2}\s*(AM|PM))\s*UTC"
    match = re.search(pattern, text)
    if not match:
        return False

    reset_time = match.group(1).strip()

    with open(RESET_TIME_FILE, "w") as f:
        f.write(reset_time)

    return True

def parse_reset_time_utc(time_str: str):
    """
    Parse Gemini reset time in UTC, e.g. '11:53 AM'
    Returns (hour, minute)
    """
    dt = datetime.strptime(time_str, "%I:%M %p")
    return dt.hour, dt.minute

def load_reset_time():
    """
    Load last reset time saved from usage-limit message.
    """
    if not os.path.exists(RESET_TIME_FILE):
        return None
    return open(RESET_TIME_FILE).read().strip()

def do_next_reset():
    banner()

    reset_str = load_reset_time()
    if not reset_str:
        cprint(NEON_RED, "[ERROR] No reset time stored from previous usage-limit message.")
        cprint(NEON_YELLOW, "Trigger a rate limit once to capture it automatically.")
        return

    # --- 1. Gemini UTC reset time ---
    hour, minute = parse_reset_time_utc(reset_str)

    # --- 2. Current true UTC time ---
    now_utc = datetime.now(timezone.utc)

    # --- 3. Build reset datetime for today ---
    reset_utc = now_utc.replace(
        hour=hour, minute=minute, second=0, microsecond=0
    )

    # --- 4. Handle rollover to tomorrow ---
    if reset_utc <= now_utc:
        reset_utc += timedelta(days=1)

    # --- 5. Compute remaining time ---
    remaining = reset_utc - now_utc
    rem_hours = remaining.seconds // 3600
    rem_minutes = (remaining.seconds % 3600) // 60

    # --- 6. Convert reset time to REAL LOCAL TZ (IST on your device) ---
    device_local_tz = datetime.now().astimezone().tzinfo
    reset_local = reset_utc.astimezone(device_local_tz)

    # --- 7. Output ---
    cprint(NEON_GREEN, f"\nNext reset in: {rem_hours} hours {rem_minutes} minutes\n")

    cprint(NEON_CYAN,   f"Reset time (UTC):   {reset_utc.strftime('%I:%M %p %Z')}")
    cprint(NEON_MAGENTA,f"Reset time (Local): {reset_local.strftime('%I:%M %p %Z')}")

    print()
    
    
def do_list_resets():
    """
    List saved reset schedules (NOT YET IMPLEMENTED).
    """
    banner()
    cprint(NEON_YELLOW, "[INFO] Listing saved reset schedules (NOT YET IMPLEMENTED)")

def remove_entry_by_id(key: str) -> bool:
    """
    Remove saved reset entry by id or email (NOT YET IMPLEMENTED).
    """
    banner()
    cprint(NEON_YELLOW, f"[INFO] Removing entry for {key} (NOT YET IMPLEMENTED)")
    return False # Placeholder - indicates not found/removed

    
    
def do_capture_reset(pasted_text: str = None):
    """
    Save a reset time from either an argument or stdin.
    Usage:
      geminiai --capture-reset "Access resets at 11:53 AM UTC."
      echo "Access resets at 11:53 AM UTC." | geminiai --capture-reset
    """
    banner()

    # Read argument or stdin
    if pasted_text:
        text = pasted_text
    else:
        # try reading from stdin if piped
        import sys
        if not sys.stdin.isatty():
            text = sys.stdin.read()
        else:
            # interactive prompt fallback
            cprint(NEON_YELLOW, "Paste the 'Access resets at ... UTC' line and press Enter:")
            try:
                text = input().strip()
            except EOFError:
                text = ""

    if not text:
        cprint(NEON_RED, "[ERROR] No input provided.")
        return

    saved = save_reset_time_from_output(text)
    if saved:
        cprint(NEON_GREEN, "[OK] Reset time saved.")
    else:
        cprint(NEON_RED, "[ERROR] Could not parse reset time. Make sure the text contains 'Access resets at HH:MM AM/PM UTC'.")